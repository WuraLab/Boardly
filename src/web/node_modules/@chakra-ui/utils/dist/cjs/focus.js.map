{"version":3,"sources":["../../src/focus.ts"],"names":["isInputElement","element","tagName","toLowerCase","getActiveElement","doc","HTMLElement","document","activeElement","focus","options","isActive","nextTick","preventScroll","triggerFocus","supportsPreventScroll","scrollableElements","getScrollableElements","restoreScrollPosition","select","requestAnimationFrame","supportsPreventScrollCached","div","createElement","e","parent","parentNode","rootScrollingElement","scrollingElement","documentElement","offsetHeight","scrollHeight","offsetWidth","scrollWidth","push","scrollTop","scrollLeft"],"mappings":"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","sourcesContent":["// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\n\nimport { getOwnerDocument } from \"./dom\"\nimport { isHTMLElement } from \"./tabbable\"\n\nexport interface FocusableElement {\n  focus(options?: FocusOptions): void\n}\n\nfunction isInputElement(\n  element: FocusableElement,\n): element is HTMLInputElement {\n  return (\n    isHTMLElement(element) &&\n    element.tagName.toLowerCase() === \"input\" &&\n    \"select\" in element\n  )\n}\n\nfunction getActiveElement(element: FocusableElement) {\n  const doc =\n    element instanceof HTMLElement ? getOwnerDocument(element) : document\n  return doc.activeElement === (element as HTMLElement)\n}\n\ninterface FocusProps extends FocusOptions {\n  /**\n   * Function that determines if the element is the active element\n   */\n  isActive?: typeof getActiveElement\n  /**\n   * If true, the element will be focused in the next tick\n   */\n  nextTick?: boolean\n}\n\nexport function focus(element: FocusableElement, options: FocusProps = {}) {\n  const {\n    isActive = getActiveElement,\n    nextTick = true,\n    preventScroll,\n  } = options\n\n  if (isActive(element)) return -1\n\n  function triggerFocus() {\n    if (supportsPreventScroll()) {\n      element.focus({ preventScroll })\n    } else {\n      element.focus()\n      if (preventScroll) {\n        const scrollableElements = getScrollableElements(element as HTMLElement)\n        restoreScrollPosition(scrollableElements)\n      }\n    }\n\n    if (isInputElement(element)) {\n      element.select()\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus)\n  }\n\n  triggerFocus()\n  return -1\n}\n\nlet supportsPreventScrollCached: boolean | null = null\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false\n    try {\n      const div = document.createElement(\"div\")\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true\n          return true\n        },\n      })\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached\n}\n\ninterface ScrollableElement {\n  element: HTMLElement\n  scrollTop: number\n  scrollLeft: number\n}\n\nfunction getScrollableElements(element: HTMLElement): ScrollableElement[] {\n  const doc = getOwnerDocument(element)\n  let parent = element.parentNode\n  const scrollableElements: ScrollableElement[] = []\n  const rootScrollingElement = doc.scrollingElement || doc.documentElement\n\n  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft,\n      })\n    }\n    parent = parent.parentNode\n  }\n\n  if (rootScrollingElement instanceof HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft,\n    })\n  }\n\n  return scrollableElements\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (const { element, scrollTop, scrollLeft } of scrollableElements) {\n    element.scrollTop = scrollTop\n    element.scrollLeft = scrollLeft\n  }\n}\n"],"file":"focus.js"}